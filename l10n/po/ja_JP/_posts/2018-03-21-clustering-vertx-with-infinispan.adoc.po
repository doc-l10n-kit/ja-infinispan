# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:1
#, fuzzy, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:11
#, fuzzy, no-wrap
msgid ""
"layout: blog\n"
"title: Clustering Vert.x with Infinispan\n"
"permalink: /blog/:year/:month/:day/clustering-vertx-with-infinispan\n"
"date: '2018-03-21T13:08:00.000-07:00'\n"
"author: karesti\n"
"tags: [ \" vert.x\" ]\n"
"thumbnail: https://4.bp.blogspot.com/-wNPoumRNOZU/WqqNdMdm6mI/AAAAAAAACNM/Nvrirnuw-ok_BfS8Gh7DaomoTGhdEwk-ACLcBGAs/s72-c/dummyApp.png\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-4888487643017555573\n"
"blogger_orig_url: https://blog.infinispan.org/2018/03/clustering-vertx-with-infinispan.html\n"
"---\n"
msgstr ""
"layout: blog\n"
"title: InfinispanによるVert.xのクラスタリング\n"
"permalink: /blog/:year/:month/:day/clustering-vertx-with-infinispan\n"
"date: '2018-03-21T13:08:00.000-07:00'\n"
"author: karesti\n"
"tags: [ \" vert.x\" ]\n"
"thumbnail: https://4.bp.blogspot.com/-wNPoumRNOZU/WqqNdMdm6mI/AAAAAAAACNM/Nvrirnuw-ok_BfS8Gh7DaomoTGhdEwk-ACLcBGAs/s72-c/dummyApp.png\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-4888487643017555573\n"
"blogger_orig_url: https://blog.infinispan.org/2018/03/clustering-vertx-with-infinispan.html\n"
"---\n"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:23
#, fuzzy
msgid "Welcome to the third in a multi-part series of blog posts about creating Eclipse Vert.x applications with Infinispan. In the previous blog posts we have seen how to create http://blog.infinispan.org/2017/12/first-steps-with-vertx-and-infinispan-rest-api.html[REST] and http://blog.infinispan.org/2017/12/first-steps-with-vertx-and-infinispan-push-api.html[PUSH] APIs using the http://infinispan.org/docs/stable/server_guide/server_guide.html[Infinispan Server]. The purpose of this tutorial is to showcase how to create clustered http://vertx.io/[Vert.x] applications using Infinispan in embedded mode."
msgstr "Infinispanを使ってEclipse Vert.xアプリケーションを作成するブログ記事シリーズの第3回目へようこそ。前回のブログ記事では、 link:http://infinispan.org/docs/stable/server_guide/server_guide.html[Infinispan サーバー] を使用して link:http://blog.infinispan.org/2017/12/first-steps-with-vertx-and-infinispan-rest-api.html[REST] と link:http://blog.infinispan.org/2017/12/first-steps-with-vertx-and-infinispan-push-api.html[PUSH] API を作成する方法を見てきました。このチュートリアルの目的は、Infinispanを使って組み込みモードでクラスタ化されたVert. link:http://vertx.io/[x] アプリケーションを作成する方法を紹介することです。"

#. type: Title ==
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:26
#, fuzzy, no-wrap
msgid "Why Infinispan ?"
msgstr "なぜInfinispanなのか？"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:41
#, fuzzy
msgid "Infinispan can be used for http://infinispan.org/about/[several use cases]. Among them we find that it can be used as the underlying framework to cluster your applications. Infinispan uses peer-to-peer communication between nodes, so the architecture is not based on master/slave mode and there is no single point of failure. Infinispan supports replication and resilience across data centers, is fast and reliable. All the http://infinispan.org/features/[features] that make this datagrid a great product, make it a great cluster manager. If you need to create clustered applications or microservices, this can be achieved with http://vertx.io/docs/#clustering[Vert.x] using the http://vertx.io/docs/vertx-infinispan/java/[Vert.x-Infinispan cluster manager]."
msgstr "Infinispan は link:http://infinispan.org/about/[いくつかのユースケースで] 使用することができます。その中でも、アプリケーションをクラスター化するための基礎となるフレームワークとして使用することができます。Infinispanはノード間のピアツーピア通信を使用するため、アーキテクチャはマスター/スレーブモードに基づいておらず、単一障害点がありません。Infinispanは、データセンター間のレプリケーションと回復力をサポートし、高速で信頼性があります。このデータグリッドを優れた製品にしているすべての link:http://infinispan.org/features/[機能] が、このデータグリッドを優れたクラスタマネージャにしています。クラスタ化されたアプリケーションやマイクロサービスを作成する必要がある場合は、Vert.x- link:http://vertx.io/docs/vertx-infinispan/java/[Infinispanクラスタマネージャ] を使用してVert. link:http://vertx.io/docs/#clustering[x] で実現できます。"

#. type: Title ==
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:44
#, fuzzy, no-wrap
msgid "Creating a clustered application"
msgstr "クラスタ化されたアプリケーションの作成"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:49
#, fuzzy
msgid "The code of this tutorial is available https://github.com/infinispan-demos/vertx-api/tree/master/clustered[here]."
msgstr "このチュートリアルのコードは link:https://github.com/infinispan-demos/vertx-api/tree/master/clustered[こちらから] ご覧いただけます。"

#. type: Title ===
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:51
#, fuzzy, no-wrap
msgid "Dummy Application"
msgstr "ダミーアプリケーション"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:55
#, fuzzy
msgid "Let’s start with a dummy clustered system with 3 verticles."
msgstr "まずは3つの頂点を持つダミーのクラスタシステムから始めてみましょう。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:59
#, fuzzy
msgid "https://4.bp.blogspot.com/-wNPoumRNOZU/WqqNdMdm6mI/AAAAAAAACNM/Nvrirnuw-ok_BfS8Gh7DaomoTGhdEwk-ACLcBGAs/s1600/dummyApp.png[image:https://4.bp.blogspot.com/-wNPoumRNOZU/WqqNdMdm6mI/AAAAAAAACNM/Nvrirnuw-ok_BfS8Gh7DaomoTGhdEwk-ACLcBGAs/s640/dummyApp.png[image,width=640,height=275]]"
msgstr "link:https://4.bp.blogspot.com/-wNPoumRNOZU/WqqNdMdm6mI/AAAAAAAACNM/Nvrirnuw-ok_BfS8Gh7DaomoTGhdEwk-ACLcBGAs/s1600/dummyApp.png[]"

#. type: Title ====
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:62
#, fuzzy, no-wrap
msgid "WebService Status Producer"
msgstr "ウェブサービス ステータス プロデューサー"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:66
#, fuzzy
msgid "Produces randomly [0,1,2] values every 1000 milliseconds and sends them to the event bus *\"ids\"* address."
msgstr "1000 ミリ秒ごとにランダムに [0,1,2] の値を生成し、イベントバスの *\"ids\"* アドレスに送信します。"

#. type: Title ====
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:71
#, fuzzy, no-wrap
msgid "Reboot Consumer"
msgstr "消費者の再起動"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:78
#, fuzzy
msgid "Consumes messages from the event bus *\"ids\"* address, and launches a *\"reboot\"* that lasts for 3000 milliseconds whenever the value is 0.  If a reboot is already happening, we don’t need to relaunch any new reboot. When a reboot starts or ends, a message is sent to the event bus to the *\"reboot\"* address."
msgstr "イベントバスの *\"ids\"* アドレスからのメッセージを消費し、値が0になるたびに3000ミリ秒続く\" *リブート\"を* 起動します。 すでにリブートが発生している場合は、新しいリブートを再起動する必要はありません。リブートが開始または終了すると、イベントバスに\"リブート *\"* アドレスにメッセージが送信されます。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:80
#, fuzzy
msgid "Notice that:"
msgstr "それに気づいてください。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:85
#, fuzzy
msgid "We use a simple boolean to check if there is a reboot going on. This is safe because every verticle is executed from a single event loop thread, so there won’t be multiple threads executing the code at the same time."
msgstr "再起動が行われているかどうかをチェックするために単純なブール値を使用しています。これは、すべての頂点が単一のイベントループスレッドから実行されるので、同時に複数のスレッドがコードを実行することはないので安全です。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:87
#, fuzzy
msgid "An ID is generated to identify the Verticle. The message sent to the event bus is a JsonObject"
msgstr "Verticle を識別するための ID が生成されます。イベントバスに送信されるメッセージは、JsonObject"

#. type: Title ====
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:92
#, fuzzy, no-wrap
msgid "Monitoring"
msgstr "モニタリング"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:96
#, fuzzy
msgid "Consumes monitoring messages from the event bus *\"reboot\"* address and logs them."
msgstr "イベントバスの *\"reboot\"* アドレスからの監視メッセージを消費し、それらをログに記録します。"

#. type: Title ===
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:101
#, fuzzy, no-wrap
msgid "Clustering the dummy Application"
msgstr "ダミーアプリケーションのクラスタリング"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:106
#, fuzzy
msgid "To create a cluster of these applications, we just need to do 2 things:"
msgstr "これらのアプリケーションのクラスタを作成するには、2つのことを行うだけです。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:110
#, fuzzy
msgid "Add the cluster manager maven dependency.   "
msgstr "cluster manager maven依存関係を追加します。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:113
#, fuzzy
msgid "Run and deploy each verticle in cluster mode. Each Verticle class has a main method that deploys each verticle separetly. Example for the Monitoring verticle."
msgstr "クラスタモードで各Verticleを実行してデプロイします。各Verticleクラスには、各Verticleを分離してデプロイするメインメソッドがあります。Monitoring verticle の例。"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:120
#, fuzzy, no-wrap
msgid "https://2.bp.blogspot.com/-GjOWQzixVq8/Wpgynw-A8OI/AAAAAAAACLQ/EUz57xgYcjcve1jXrARPEufaOLfLErUDwCEwYBhgL/s1600/Monitoring.png[image:https://2.bp.blogspot.com/-GjOWQzixVq8/Wpgynw-A8OI/AAAAAAAACLQ/EUz57xgYcjcve1jXrARPEufaOLfLErUDwCEwYBhgL/s320/Monitoring.png[image,width=320,height=296]]"
msgstr "link:https://2.bp.blogspot.com/-GjOWQzixVq8/Wpgynw-A8OI/AAAAAAAACLQ/EUz57xgYcjcve1jXrARPEufaOLfLErUDwCEwYBhgL/s1600/Monitoring.png[]"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:121
#, fuzzy, no-wrap
msgid "Running the application, we can monitor the logs"
msgstr "アプリケーションを実行すると、ログを監視することができます。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:126
#, fuzzy
msgid "Each clustered application contains - or embeds - an Infinispan instance. Under the hood, the 3 Infinispan instances will form a cluster."
msgstr "各クラスタ化されたアプリケーションには、1つのInfinispanインスタンスが含まれています。3つのInfinispanインスタンスがクラスタを形成します。"

#. type: Title ==
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:129
#, fuzzy, no-wrap
msgid "What if I need to scale"
msgstr "スケールが必要な場合は？"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:138
#, fuzzy
msgid "Imagine you need to scale the Reboot Consumer application. We can run it multiple times, let’s say 2 more times. The two new instances will join the cluster. In this case, we have “ID-93EB” ”ID-45B8” and “ID-247A”, so now we have a cluster of 5. It's very simple but if we have a look to the monitoring console, we will notice reboots are now happening in parallel."
msgstr "Reboot Consumerアプリケーションをスケールする必要があると想像してください。これを複数回実行して、さらに2回としましょう。2つの新しいインスタンスがクラスタに参加します。この場合、\"ID-93EB\" \"ID-45B8\" \"ID-247A\"があるので、これで5つのクラスタになりました。非常にシンプルですが、モニタリングコンソールを見てみると、再起動が並行して行われるようになっていることがわかります。"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:144
#, fuzzy, no-wrap
msgid "https://3.bp.blogspot.com/-YTja7FV8S4k/Wpg6YuIstTI/AAAAAAAACL4/xH2N4erfgfk_ZUcICwmyp_2WQQNKlPpqQCLcBGAs/s1600/MultipleReboots.png[image:https://3.bp.blogspot.com/-YTja7FV8S4k/Wpg6YuIstTI/AAAAAAAACL4/xH2N4erfgfk_ZUcICwmyp_2WQQNKlPpqQCLcBGAs/s400/MultipleReboots.png[image,width=400,height=245]]"
msgstr "link:https://3.bp.blogspot.com/-YTja7FV8S4k/Wpg6YuIstTI/AAAAAAAACL4/xH2N4erfgfk_ZUcICwmyp_2WQQNKlPpqQCLcBGAs/s1600/MultipleReboots.png[]"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:145
#, fuzzy, no-wrap
msgid "3 Reboot Consumers"
msgstr "3 消費者の再起動"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:154
#, fuzzy
msgid "As I mentioned before, this example is a dummy application. But in real life you could need to trigger a process from a verticle that runs multiple times and need to be sure this process is happening just once at a time. How can we fix this ? We can use Vert.x Shared Data structures API."
msgstr "前に述べたように、この例はダミーアプリケーションです。しかし、実際の生活では、複数回実行される頂点からプロセスをトリガーする必要があり、このプロセスが一度に一度だけ発生していることを確認する必要があるかもしれません。これを解決するにはどうすればいいのでしょうか？Vert.x共有データ構造APIを使用することができます。"

#. type: Title ===
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:156
#, fuzzy, no-wrap
msgid "Shared data API to rescue"
msgstr "レスキューするための共有データAPI"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:161
#, fuzzy
msgid "In this particular case, we are going to use a clustered lock. Using the lock, we can now synchronise the reboots among the 3 nodes."
msgstr "この特定のケースでは、クラスター化されたロックを使用します。ロックを使用することで、3つのノード間で再起動を同期させることができます。"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:169
#, fuzzy, no-wrap
msgid "https://2.bp.blogspot.com/--calcYXn5l4/WplAZEu4f8I/AAAAAAAACMU/eFrivRZMsHE8XUZr-BAvAuUikZ9-_k3DACLcBGAs/s1600/MonitoringUsingLock.png[image:https://2.bp.blogspot.com/--calcYXn5l4/WplAZEu4f8I/AAAAAAAACMU/eFrivRZMsHE8XUZr-BAvAuUikZ9-_k3DACLcBGAs/s400/MonitoringUsingLock.png[image,width=400,height=256]]"
msgstr "link:https://2.bp.blogspot.com/--calcYXn5l4/WplAZEu4f8I/AAAAAAAACMU/eFrivRZMsHE8XUZr-BAvAuUikZ9-_k3DACLcBGAs/s1600/MonitoringUsingLock.png[]"

#. type: Table
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:170
#, fuzzy, no-wrap
msgid "Using Shared Data API, one reboot at a time"
msgstr "共有データAPIを使用して、一度に1つの再起動を行います。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:180
#, fuzzy
msgid "Vert.x clustered lock in this example is using an emulated version of the new Clustered Lock API of Infinispan introduced in 9.2 which has been freshly released. I will come back to share about this API in particular in further blog posts. You can read about it on the http://infinispan.org/docs/stable/user_guide/user_guide.html#clustered_lock[documentation] or run the https://github.com/infinispan/infinispan-simple-tutorials/tree/master/lock[infinispan-simple-tutorial]."
msgstr "この例の Vert.x クラスタリングロックは、9.2 でリリースされたばかりの Infinispan の新しい Clustered Lock API のエミュレート版を使用しています。特にこの API については、また別のブログ記事で紹介します。 link:http://infinispan.org/docs/stable/user_guide/user_guide.html#clustered_lock[ドキュメント] を読むか、 link:https://github.com/infinispan/infinispan-simple-tutorials/tree/master/lock[infinispan-simple-tutorial] を実行してください。"

#. type: Title ===
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:182
#, fuzzy, no-wrap
msgid "One node at a time"
msgstr "一度に一つのノード"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:201
#, fuzzy
msgid "When clustering applications with Vert.x, there is something you need to take care of. It is important to understand that each node contains an instance of the datagrid. This means that scaling up and down needs to be done one at a time. Infinispan, as other datagrids, reshuffles the data when a new node joins or leaves a cluster. This process is done following a distributed hashing algorithm, so not every data is moved around, just the data that is supposed to live in the new node, or the data owned by a leaving node. If we just kill a bunch of nodes without taking care of the cluster, consequences can be harming! This is something quite obvious when dealing with databases : we just don’t kill a bunch of database instances without taking care of every instance at a time. Even when Infinispan data is only in memory we need to take care about it in the same way. http://vertx.io/docs/vertx-infinispan/java/#_configuring_for_kubernetes_or_openshift_3[Openshift, which is built on top of Kubernetes], helps dealing properly and safely with these scale up and down operations."
msgstr "Vert.xでアプリケーションをクラスタリングする場合、注意しなければならないことがあります。各ノードにはデータグリッドのインスタンスが含まれていることを理解することが重要です。つまり、スケールアップやスケールダウンは1つずつ行う必要があります。Infinispanは、他のデータグリッドと同様に、新しいノードがクラスタに参加したり離れたりすると、データを再シャッフルします。この処理は分散ハッシュアルゴリズムに従って行われるので、すべてのデータが移動されるわけではなく、新しいノードに存在すると思われるデータや、退出するノードが所有するデータだけが移動されます。クラスタの世話をせずにノードの束を殺してしまうと、結果的に害を及ぼす可能性があります。これはデータベースを扱う場合には明白なことです: 一度にすべてのインスタンスの世話をしないでデータベースインスタンスの束を殺すことはありません。 link:http://vertx.io/docs/vertx-infinispan/java/#_configuring_for_kubernetes_or_openshift_3[Kubernetesの上に構築されているOpenshiftは] 、このようなスケールアップやスケールダウンの操作を適切かつ安全に行うのに役立ちます。"

#. type: Title ==
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:204
#, fuzzy, no-wrap
msgid "Conclusions"
msgstr "結論"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:215
#, fuzzy
msgid "As you have seen, creating clustered applications with Vert.x and Infinispan is very straightforward. The clustered event bus is very powerful. In this example we have seen how to use a clustered lock, but other http://vertx.io/docs/apidocs/io/vertx/core/shareddata/SharedData.html[shared data structures] built on top of http://infinispan.org/docs/stable/user_guide/user_guide.html#the_code_strongcounter_code_interface_when_the_consistency_or_bounds_matters[Counters] are available."
msgstr "これまで見てきたように、Vert.x と Infinispan を使ってクラスタ化されたアプリケーションを作成するのは非常に簡単です。クラスタ化されたイベントバスは非常に強力です。この例では、クラスター化されたロックを使用する方法を見てきましたが、Counters の上に構築された他の link:http://vertx.io/docs/apidocs/io/vertx/core/shareddata/SharedData.html[共有データ構造] も利用でき link:http://infinispan.org/docs/stable/user_guide/user_guide.html#the_code_strongcounter_code_interface_when_the_consistency_or_bounds_matters[ます] 。"

#. type: Title ==
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:218
#, fuzzy, no-wrap
msgid "About the Vert.x Infinispan Cluster Manager status"
msgstr "Vert.x Infinispan Cluster Managerのステータスについて"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:228
#, fuzzy
msgid "At the time of this writing, http://blog.infinispan.org/2018/02/infinispan-920final.html[Infinspan 9.2.0.Final] has been released. From vert.x-infinispan cluster manager point of view, before Vert.x 3.6 (which is not out yet) the cluster manager is using Infinispan 9.1.6.final and it’s using an emulation layer for locks and counters. In this tutorial we are using Vert.x 3.5.1 version."
msgstr "この記事を書いている時点で、 link:http://blog.infinispan.org/2018/02/infinispan-920final.html[Infinspan 9.2.0.] Finalがリリースされています。Vert.x-infinispanクラスタマネージャの視点から見ると、Vert.x 3.6（まだ出ていません）以前のクラスタマネージャはInfinispan 9.1.6.finalを使用しており、ロックとカウンタのためにエミュレーションレイヤーを使用しています。このチュートリアルではVert.x 3.5.1バージョンを使用しています。"

#. type: Plain text
#: upstream/_posts/2018-03-21-clustering-vertx-with-infinispan.adoc:233
#, fuzzy
msgid "This tutorial will be updated with the version using Infinispan 9.2 as soon as the next https://github.com/vert-x3/vertx-infinispan/[vert.x-infinispan] will be released, which will happen in a few months. Meanwhile, stay tuned!"
msgstr "このチュートリアルは、次の link:https://github.com/vert-x3/vertx-infinispan/[vert.x-infinispan] がリリースされ次第、Infinispan 9.2 を使用したバージョンに更新されます。その間、ご期待ください"
